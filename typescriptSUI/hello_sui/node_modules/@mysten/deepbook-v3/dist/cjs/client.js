"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var client_exports = {};
__export(client_exports, {
  DeepBookClient: () => DeepBookClient
});
module.exports = __toCommonJS(client_exports);
var import_bcs = require("@mysten/sui/bcs");
var import_transactions = require("@mysten/sui/transactions");
var import_utils = require("@mysten/sui/utils");
var import_balanceManager = require("./transactions/balanceManager.js");
var import_deepbook = require("./transactions/deepbook.js");
var import_deepbookAdmin = require("./transactions/deepbookAdmin.js");
var import_flashLoans = require("./transactions/flashLoans.js");
var import_governance = require("./transactions/governance.js");
var import_config = require("./utils/config.js");
var _config, _address;
class DeepBookClient {
  /**
   * @param {SuiClient} client SuiClient instance
   * @param {string} address Address of the client
   * @param {Environment} env Environment configuration
   * @param {Object.<string, BalanceManager>} [balanceManagers] Optional initial BalanceManager map
   * @param {CoinMap} [coins] Optional initial CoinMap
   * @param {PoolMap} [pools] Optional initial PoolMap
   * @param {string} [adminCap] Optional admin capability
   */
  constructor({
    client,
    address,
    env,
    balanceManagers,
    coins,
    pools,
    adminCap
  }) {
    __privateAdd(this, _config);
    __privateAdd(this, _address);
    this.client = client;
    __privateSet(this, _address, (0, import_utils.normalizeSuiAddress)(address));
    __privateSet(this, _config, new import_config.DeepBookConfig({
      address: __privateGet(this, _address),
      env,
      balanceManagers,
      coins,
      pools,
      adminCap
    }));
    this.balanceManager = new import_balanceManager.BalanceManagerContract(__privateGet(this, _config));
    this.deepBook = new import_deepbook.DeepBookContract(__privateGet(this, _config));
    this.deepBookAdmin = new import_deepbookAdmin.DeepBookAdminContract(__privateGet(this, _config));
    this.flashLoans = new import_flashLoans.FlashLoanContract(__privateGet(this, _config));
    this.governance = new import_governance.GovernanceContract(__privateGet(this, _config));
  }
  /**
   * @description Check the balance of a balance manager for a specific coin
   * @param {string} managerKey Key of the balance manager
   * @param {string} coinKey Key of the coin
   * @returns {Promise<{ coinType: string, balance: number }>} An object with coin type and balance
   */
  async checkManagerBalance(managerKey, coinKey) {
    const tx = new import_transactions.Transaction();
    const coin = __privateGet(this, _config).getCoin(coinKey);
    tx.add(this.balanceManager.checkManagerBalance(managerKey, coinKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: __privateGet(this, _address),
      transactionBlock: tx
    });
    const bytes = res.results[0].returnValues[0][0];
    const parsed_balance = import_bcs.bcs.U64.parse(new Uint8Array(bytes));
    const balanceNumber = Number(parsed_balance);
    const adjusted_balance = balanceNumber / coin.scalar;
    return {
      coinType: coin.type,
      balance: Number(adjusted_balance.toFixed(9))
    };
  }
  /**
   * @description Check if a pool is whitelisted
   * @param {string} poolKey Key of the pool
   * @returns {Promise<boolean>} Boolean indicating if the pool is whitelisted
   */
  async whitelisted(poolKey) {
    const tx = new import_transactions.Transaction();
    tx.add(this.deepBook.whitelisted(poolKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const bytes = res.results[0].returnValues[0][0];
    const whitelisted = import_bcs.bcs.Bool.parse(new Uint8Array(bytes));
    return whitelisted;
  }
  /**
   * @description Get the quote quantity out for a given base quantity
   * @param {string} poolKey Key of the pool
   * @param {number} baseQuantity Base quantity to convert
   * @returns {Promise<{ baseQuantity: number, baseOut: number, quoteOut: number, deepRequired: number }>}
   * An object with base quantity, base out, quote out, and deep required for the dry run
   */
  async getQuoteQuantityOut(poolKey, baseQuantity) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.getQuoteQuantityOut(poolKey, baseQuantity));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const baseOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const quoteOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const deepRequired = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0])));
    return {
      baseQuantity,
      baseOut: Number((baseOut / baseScalar).toFixed(9)),
      quoteOut: Number((quoteOut / quoteScalar).toFixed(9)),
      deepRequired: Number((deepRequired / import_config.DEEP_SCALAR).toFixed(9))
    };
  }
  /**
   * @description Get the base quantity out for a given quote quantity
   * @param {string} poolKey Key of the pool
   * @param {number} quoteQuantity Quote quantity to convert
   * @returns {Promise<{ quoteQuantity: number, baseOut: number, quoteOut: number, deepRequired: number }>}
   * An object with quote quantity, base out, quote out, and deep required for the dry run
   */
  async getBaseQuantityOut(poolKey, quoteQuantity) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.getBaseQuantityOut(poolKey, quoteQuantity));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const baseOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const quoteOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const deepRequired = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0])));
    return {
      quoteQuantity,
      baseOut: Number((baseOut / baseScalar).toFixed(9)),
      quoteOut: Number((quoteOut / quoteScalar).toFixed(9)),
      deepRequired: Number((deepRequired / import_config.DEEP_SCALAR).toFixed(9))
    };
  }
  /**
   * @description Get the output quantities for given base and quote quantities. Only one quantity can be non-zero
   * @param {string} poolKey Key of the pool
   * @param {number} baseQuantity Base quantity to convert
   * @param {number} quoteQuantity Quote quantity to convert
   * @returns {Promise<{ baseQuantity: number, quoteQuantity: number, baseOut: number, quoteOut: number, deepRequired: number }>}
   * An object with base quantity, quote quantity, base out, quote out, and deep required for the dry run
   */
  async getQuantityOut(poolKey, baseQuantity, quoteQuantity) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.getQuantityOut(poolKey, baseQuantity, quoteQuantity));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const baseOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const quoteOut = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const deepRequired = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0])));
    return {
      baseQuantity,
      quoteQuantity,
      baseOut: Number((baseOut / baseScalar).toFixed(9)),
      quoteOut: Number((quoteOut / quoteScalar).toFixed(9)),
      deepRequired: Number((deepRequired / import_config.DEEP_SCALAR).toFixed(9))
    };
  }
  /**
   * @description Get open orders for a balance manager in a pool
   * @param {string} poolKey Key of the pool
   * @param {string} managerKey Key of the balance manager
   * @returns {Promise<Array>} An array of open order IDs
   */
  async accountOpenOrders(poolKey, managerKey) {
    const tx = new import_transactions.Transaction();
    tx.add(this.deepBook.accountOpenOrders(poolKey, managerKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const order_ids = res.results[0].returnValues[0][0];
    const VecSet = import_bcs.bcs.struct("VecSet", {
      constants: import_bcs.bcs.vector(import_bcs.bcs.U128)
    });
    return VecSet.parse(new Uint8Array(order_ids)).constants;
  }
  /**
   * @description Get the order information for a specific order in a pool
   * @param {string} poolKey Key of the pool
   * @param {string} orderId Order ID
   * @returns {Promise<Object>} A promise that resolves to an object containing the order information
   */
  async getOrder(poolKey, orderId) {
    const tx = new import_transactions.Transaction();
    tx.add(this.deepBook.getOrder(poolKey, orderId));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const ID = import_bcs.bcs.struct("ID", {
      bytes: import_bcs.bcs.Address
    });
    const OrderDeepPrice = import_bcs.bcs.struct("OrderDeepPrice", {
      asset_is_base: import_bcs.bcs.bool(),
      deep_per_asset: import_bcs.bcs.u64()
    });
    const Order = import_bcs.bcs.struct("Order", {
      balance_manager_id: ID,
      order_id: import_bcs.bcs.u128(),
      client_order_id: import_bcs.bcs.u64(),
      quantity: import_bcs.bcs.u64(),
      filled_quantity: import_bcs.bcs.u64(),
      fee_is_deep: import_bcs.bcs.bool(),
      order_deep_price: OrderDeepPrice,
      epoch: import_bcs.bcs.u64(),
      status: import_bcs.bcs.u8(),
      expire_timestamp: import_bcs.bcs.u64()
    });
    try {
      const orderInformation = res.results[0].returnValues[0][0];
      return Order.parse(new Uint8Array(orderInformation));
    } catch (e) {
      return null;
    }
  }
  /**
   * @description Get level 2 order book specifying range of price
   * @param {string} poolKey Key of the pool
   * @param {number} priceLow Lower bound of the price range
   * @param {number} priceHigh Upper bound of the price range
   * @param {boolean} isBid Whether to get bid or ask orders
   * @returns {Promise<{ prices: Array<number>, quantities: Array<number> }>}
   * An object with arrays of prices and quantities
   */
  async getLevel2Range(poolKey, priceLow, priceHigh, isBid) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
    const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
    tx.add(this.deepBook.getLevel2Range(poolKey, priceLow, priceHigh, isBid));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const prices = res.results[0].returnValues[0][0];
    const parsed_prices = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(prices));
    const quantities = res.results[0].returnValues[1][0];
    const parsed_quantities = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(quantities));
    return {
      prices: parsed_prices.map(
        (price) => Number((Number(price) / import_config.FLOAT_SCALAR / quoteCoin.scalar * baseCoin.scalar).toFixed(9))
      ),
      quantities: parsed_quantities.map(
        (price) => Number((Number(price) / baseCoin.scalar).toFixed(9))
      )
    };
  }
  /**
   * @description Get level 2 order book ticks from mid-price for a pool
   * @param {string} poolKey Key of the pool
   * @param {number} ticks Number of ticks from mid-price
   * @returns {Promise<{ bid_prices: Array<number>, bid_quantities: Array<number>, ask_prices: Array<number>, ask_quantities: Array<number> }>}
   * An object with arrays of prices and quantities
   */
  async getLevel2TicksFromMid(poolKey, ticks) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
    const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
    tx.add(this.deepBook.getLevel2TicksFromMid(poolKey, ticks));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const bid_prices = res.results[0].returnValues[0][0];
    const bid_parsed_prices = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(bid_prices));
    const bid_quantities = res.results[0].returnValues[1][0];
    const bid_parsed_quantities = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(bid_quantities));
    const ask_prices = res.results[0].returnValues[2][0];
    const ask_parsed_prices = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(ask_prices));
    const ask_quantities = res.results[0].returnValues[3][0];
    const ask_parsed_quantities = import_bcs.bcs.vector(import_bcs.bcs.u64()).parse(new Uint8Array(ask_quantities));
    return {
      bid_prices: bid_parsed_prices.map(
        (price) => Number((Number(price) / import_config.FLOAT_SCALAR / quoteCoin.scalar * baseCoin.scalar).toFixed(9))
      ),
      bid_quantities: bid_parsed_quantities.map(
        (quantity) => Number((Number(quantity) / baseCoin.scalar).toFixed(9))
      ),
      ask_prices: ask_parsed_prices.map(
        (price) => Number((Number(price) / import_config.FLOAT_SCALAR / quoteCoin.scalar * baseCoin.scalar).toFixed(9))
      ),
      ask_quantities: ask_parsed_quantities.map(
        (quantity) => Number((Number(quantity) / baseCoin.scalar).toFixed(9))
      )
    };
  }
  /**
   * @description Get the vault balances for a pool
   * @param {string} poolKey Key of the pool
   * @returns {Promise<{ base: number, quote: number, deep: number }>}
   * An object with base, quote, and deep balances in the vault
   */
  async vaultBalances(poolKey) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.vaultBalances(poolKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const baseInVault = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const quoteInVault = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const deepInVault = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0])));
    return {
      base: Number((baseInVault / baseScalar).toFixed(9)),
      quote: Number((quoteInVault / quoteScalar).toFixed(9)),
      deep: Number((deepInVault / import_config.DEEP_SCALAR).toFixed(9))
    };
  }
  /**
   * @description Get the pool ID by asset types
   * @param {string} baseType Type of the base asset
   * @param {string} quoteType Type of the quote asset
   * @returns {Promise<string>} The address of the pool
   */
  async getPoolIdByAssets(baseType, quoteType) {
    const tx = new import_transactions.Transaction();
    tx.add(this.deepBook.getPoolIdByAssets(baseType, quoteType));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const ID = import_bcs.bcs.struct("ID", {
      bytes: import_bcs.bcs.Address
    });
    const address = ID.parse(new Uint8Array(res.results[0].returnValues[0][0]))["bytes"];
    return address;
  }
  /**
   * @description Get the mid price for a pool
   * @param {string} poolKey Key of the pool
   * @returns {Promise<number>} The mid price
   */
  async midPrice(poolKey) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    tx.add(this.deepBook.midPrice(poolKey));
    const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
    const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const bytes = res.results[0].returnValues[0][0];
    const parsed_mid_price = Number(import_bcs.bcs.U64.parse(new Uint8Array(bytes)));
    const adjusted_mid_price = parsed_mid_price * baseCoin.scalar / quoteCoin.scalar / import_config.FLOAT_SCALAR;
    return Number(adjusted_mid_price.toFixed(9));
  }
  /**
   * @description Get the trade parameters for a given pool, including taker fee, maker fee, and stake required.
   * @param {string} poolKey Key of the pool
   * @returns {Promise<{ takerFee: number, makerFee: number, stakeRequired: number }>}
   */
  async poolTradeParams(poolKey) {
    const tx = new import_transactions.Transaction();
    tx.add(this.deepBook.poolTradeParams(poolKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const takerFee = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const makerFee = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const stakeRequired = Number(
      import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0]))
    );
    return {
      takerFee: Number(takerFee / import_config.FLOAT_SCALAR),
      makerFee: Number(makerFee / import_config.FLOAT_SCALAR),
      stakeRequired: Number(stakeRequired / import_config.DEEP_SCALAR)
    };
  }
  /**
   * @description Get the trade parameters for a given pool, including tick size, lot size, and min size.
   * @param {string} poolKey Key of the pool
   * @returns {Promise<{ tickSize: number, lotSize: number, minSize: number }>}
   */
  async poolBookParams(poolKey) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.poolBookParams(poolKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const tickSize = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[0][0])));
    const lotSize = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[1][0])));
    const minSize = Number(import_bcs.bcs.U64.parse(new Uint8Array(res.results[0].returnValues[2][0])));
    return {
      tickSize: Number(tickSize * baseScalar / quoteScalar / import_config.FLOAT_SCALAR),
      lotSize: Number(lotSize / baseScalar),
      minSize: Number(minSize / baseScalar)
    };
  }
  /**
   * @description Get the account information for a given pool and balance manager
   * @param {string} poolKey Key of the pool
   * @param {string} managerKey The key of the BalanceManager
   * @returns {Promise<Object>} A promise that resolves to an object containing the account information
   */
  async account(poolKey, managerKey) {
    const tx = new import_transactions.Transaction();
    const pool = __privateGet(this, _config).getPool(poolKey);
    const baseScalar = __privateGet(this, _config).getCoin(pool.baseCoin).scalar;
    const quoteScalar = __privateGet(this, _config).getCoin(pool.quoteCoin).scalar;
    tx.add(this.deepBook.account(poolKey, managerKey));
    const res = await this.client.devInspectTransactionBlock({
      sender: (0, import_utils.normalizeSuiAddress)(__privateGet(this, _address)),
      transactionBlock: tx
    });
    const ID = import_bcs.bcs.struct("ID", {
      bytes: import_bcs.bcs.Address
    });
    const Balances = import_bcs.bcs.struct("Balances", {
      base: import_bcs.bcs.u64(),
      quote: import_bcs.bcs.u64(),
      deep: import_bcs.bcs.u64()
    });
    const VecSet = import_bcs.bcs.struct("VecSet", {
      constants: import_bcs.bcs.vector(import_bcs.bcs.U128)
    });
    const Account = import_bcs.bcs.struct("Account", {
      epoch: import_bcs.bcs.u64(),
      open_orders: VecSet,
      taker_volume: import_bcs.bcs.u128(),
      maker_volume: import_bcs.bcs.u128(),
      active_stake: import_bcs.bcs.u64(),
      inactive_stake: import_bcs.bcs.u64(),
      created_proposal: import_bcs.bcs.bool(),
      voted_proposal: import_bcs.bcs.option(ID),
      unclaimed_rebates: Balances,
      settled_balances: Balances,
      owed_balances: Balances
    });
    const accountInformation = res.results[0].returnValues[0][0];
    const accountInfo = Account.parse(new Uint8Array(accountInformation));
    return {
      epoch: accountInfo.epoch,
      open_orders: accountInfo.open_orders,
      taker_volume: Number(accountInfo.taker_volume) / baseScalar,
      maker_volume: Number(accountInfo.maker_volume) / baseScalar,
      active_stake: Number(accountInfo.active_stake) / import_config.DEEP_SCALAR,
      inactive_stake: Number(accountInfo.inactive_stake) / import_config.DEEP_SCALAR,
      created_proposal: accountInfo.created_proposal,
      voted_proposal: accountInfo.voted_proposal,
      unclaimed_rebates: {
        base: Number(accountInfo.unclaimed_rebates.base) / baseScalar,
        quote: Number(accountInfo.unclaimed_rebates.quote) / quoteScalar,
        deep: Number(accountInfo.unclaimed_rebates.deep) / import_config.DEEP_SCALAR
      },
      settled_balances: {
        base: Number(accountInfo.settled_balances.base) / baseScalar,
        quote: Number(accountInfo.settled_balances.quote) / quoteScalar,
        deep: Number(accountInfo.settled_balances.deep) / import_config.DEEP_SCALAR
      },
      owed_balances: {
        base: Number(accountInfo.owed_balances.base) / baseScalar,
        quote: Number(accountInfo.owed_balances.quote) / quoteScalar,
        deep: Number(accountInfo.owed_balances.deep) / import_config.DEEP_SCALAR
      }
    };
  }
}
_config = new WeakMap();
_address = new WeakMap();
//# sourceMappingURL=client.js.map
