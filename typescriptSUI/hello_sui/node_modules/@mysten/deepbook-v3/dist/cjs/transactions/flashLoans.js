"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var flashLoans_exports = {};
__export(flashLoans_exports, {
  FlashLoanContract: () => FlashLoanContract
});
module.exports = __toCommonJS(flashLoans_exports);
var _config;
class FlashLoanContract {
  /**
   * @param {DeepBookConfig} config Configuration object for DeepBook
   */
  constructor(config) {
    __privateAdd(this, _config);
    /**
     * @description Borrow base asset from the pool
     * @param {string} poolKey The key to identify the pool
     * @param {number} borrowAmount The amount to borrow
     * @returns A function that takes a Transaction object
     */
    this.borrowBaseAsset = (poolKey, borrowAmount) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const inputQuantity = Math.round(borrowAmount * baseCoin.scalar);
      const [baseCoinResult, flashLoan] = tx.moveCall({
        target: `${__privateGet(this, _config).DEEPBOOK_PACKAGE_ID}::pool::borrow_flashloan_base`,
        arguments: [tx.object(pool.address), tx.pure.u64(inputQuantity)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
      return [baseCoinResult, flashLoan];
    };
    /**
     * @description Return base asset to the pool after a flash loan.
     * @param {string} poolKey The key to identify the pool
     * @param {number} borrowAmount The amount of the base asset to return
     * @param {TransactionObjectArgument} baseCoinInput Coin object representing the base asset to be returned
     * @param {TransactionObjectArgument} flashLoan FlashLoan object representing the loan to be settled
     * @returns A function that takes a Transaction object
     */
    this.returnBaseAsset = (poolKey, borrowAmount, baseCoinInput, flashLoan) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const borrowScalar = baseCoin.scalar;
      const [baseCoinReturn] = tx.splitCoins(baseCoinInput, [
        tx.pure.u64(Math.round(borrowAmount * borrowScalar))
      ]);
      tx.moveCall({
        target: `${__privateGet(this, _config).DEEPBOOK_PACKAGE_ID}::pool::return_flashloan_base`,
        arguments: [tx.object(pool.address), baseCoinReturn, flashLoan],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
      return baseCoinInput;
    };
    /**
     * @description Borrow quote asset from the pool
     * @param {string} poolKey The key to identify the pool
     * @param {number} borrowAmount The amount to borrow
     * @returns A function that takes a Transaction object
     */
    this.borrowQuoteAsset = (poolKey, borrowAmount) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const inputQuantity = Math.round(borrowAmount * quoteCoin.scalar);
      const [quoteCoinResult, flashLoan] = tx.moveCall({
        target: `${__privateGet(this, _config).DEEPBOOK_PACKAGE_ID}::pool::borrow_flashloan_quote`,
        arguments: [tx.object(pool.address), tx.pure.u64(inputQuantity)],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
      return [quoteCoinResult, flashLoan];
    };
    /**
     * @description Return quote asset to the pool after a flash loan.
     * @param {string} poolKey The key to identify the pool
     * @param {number} borrowAmount The amount of the quote asset to return
     * @param {TransactionObjectArgument} quoteCoinInput Coin object representing the quote asset to be returned
     * @param {TransactionObjectArgument} flashLoan FlashLoan object representing the loan to be settled
     * @returns A function that takes a Transaction object
     */
    this.returnQuoteAsset = (poolKey, borrowAmount, quoteCoinInput, flashLoan) => (tx) => {
      const pool = __privateGet(this, _config).getPool(poolKey);
      const baseCoin = __privateGet(this, _config).getCoin(pool.baseCoin);
      const quoteCoin = __privateGet(this, _config).getCoin(pool.quoteCoin);
      const borrowScalar = quoteCoin.scalar;
      const [quoteCoinReturn] = tx.splitCoins(quoteCoinInput, [
        tx.pure.u64(Math.round(borrowAmount * borrowScalar))
      ]);
      tx.moveCall({
        target: `${__privateGet(this, _config).DEEPBOOK_PACKAGE_ID}::pool::return_flashloan_quote`,
        arguments: [tx.object(pool.address), quoteCoinReturn, flashLoan],
        typeArguments: [baseCoin.type, quoteCoin.type]
      });
      return quoteCoinInput;
    };
    __privateSet(this, _config, config);
  }
}
_config = new WeakMap();
//# sourceMappingURL=flashLoans.js.map
